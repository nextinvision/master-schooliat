import { Router } from "express";
import { readFileSync } from "fs";
import { join, dirname } from "path";
import { fileURLToPath } from "url";
import prisma from "../prisma/client.js";
import withPermission from "../middlewares/with-permission.middleware.js";
import {
  Permission,
  PaymentMethod,
  ReceiptStatus,
} from "../prisma/generated/index.js";
import paginateUtil from "../utils/paginate.util.js";

// Get current directory for ES modules
const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

// Load receipt template
const getReceiptTemplate = () => {
  const templatePath = join(__dirname, "../templates/schooliat-receipt.html");
  return readFileSync(templatePath, "utf-8");
};

// Convert number to words (Indian format)
const numberToWords = (num) => {
  const ones = [
    "",
    "One",
    "Two",
    "Three",
    "Four",
    "Five",
    "Six",
    "Seven",
    "Eight",
    "Nine",
    "Ten",
    "Eleven",
    "Twelve",
    "Thirteen",
    "Fourteen",
    "Fifteen",
    "Sixteen",
    "Seventeen",
    "Eighteen",
    "Nineteen",
  ];
  const tens = [
    "",
    "",
    "Twenty",
    "Thirty",
    "Forty",
    "Fifty",
    "Sixty",
    "Seventy",
    "Eighty",
    "Ninety",
  ];

  if (num === 0) return "Zero";

  const convertLessThanThousand = (n) => {
    if (n === 0) return "";
    if (n < 20) return ones[n];
    if (n < 100)
      return (
        tens[Math.floor(n / 10)] + (n % 10 !== 0 ? " " + ones[n % 10] : "")
      );
    return (
      ones[Math.floor(n / 100)] +
      " Hundred" +
      (n % 100 !== 0 ? " " + convertLessThanThousand(n % 100) : "")
    );
  };

  const intPart = Math.floor(num);
  const decPart = Math.round((num - intPart) * 100);

  let words = "";

  if (intPart >= 10000000) {
    words +=
      convertLessThanThousand(Math.floor(intPart / 10000000)) + " Crore ";
    num = intPart % 10000000;
  } else {
    num = intPart;
  }

  if (num >= 100000) {
    words += convertLessThanThousand(Math.floor(num / 100000)) + " Lakh ";
    num = num % 100000;
  }

  if (num >= 1000) {
    words += convertLessThanThousand(Math.floor(num / 1000)) + " Thousand ";
    num = num % 1000;
  }

  if (num > 0) {
    words += convertLessThanThousand(num);
  }

  words = words.trim() + " Rupees";

  if (decPart > 0) {
    words += " and " + convertLessThanThousand(decPart) + " Paise";
  }

  return words + " Only";
};

const router = Router();

// Receipt number is now auto-generated by the database using a sequence
// Format: RCP + 10-digit padded sequence number (e.g., RCP0000000001)

router.post(
  "/",
  withPermission(Permission.CREATE_RECEIPT),
  async (req, res) => {
    const request = req.body.request;
    const currentUser = req.context.user;
    const {
      schoolId,
      receiptNumber: providedReceiptNumber,
      baseAmount,
      sgstPercent,
      cgstPercent,
      igstPercent,
      ugstPercent,
      description,
      paymentMethod,
    } = request;
    // Validate school exists
    await prisma.school.findUniqueOrThrow({
      where: { id: schoolId },
    });

    // Receipt number is auto-generated by database if not provided
    // Only use provided receipt number if explicitly given (for manual override)

    // Calculate GST amounts
    const base = baseAmount ? parseFloat(baseAmount) : 0;
    const sgst = sgstPercent ? parseFloat(sgstPercent) : 0;
    const cgst = cgstPercent ? parseFloat(cgstPercent) : 0;
    const igst = igstPercent ? parseFloat(igstPercent) : 0;
    const ugst = ugstPercent ? parseFloat(ugstPercent) : 0;

    const sgstAmount = sgst > 0 ? (base * sgst) / 100 : 0;
    const cgstAmount = cgst > 0 ? (base * cgst) / 100 : 0;
    const igstAmount = igst > 0 ? (base * igst) / 100 : 0;
    const ugstAmount = ugst > 0 ? (base * ugst) / 100 : 0;
    const totalGst = sgstAmount + cgstAmount + igstAmount + ugstAmount;
    const totalAmount = base + totalGst;

    // Map payment method string to enum
    const paymentMethodEnum =
      PaymentMethod[paymentMethod.replace(/\s+/g, "_").toUpperCase()] ||
      PaymentMethod.BANK_TRANSFER;

    // Only include receiptNumber if explicitly provided (for manual override)
    // Otherwise, it will be auto-generated by the database
    const receiptData = {
      ...(providedReceiptNumber && { receiptNumber: providedReceiptNumber }),
      schoolId,
      baseAmount: base.toString(),
      sgstPercent: sgst > 0 ? sgst.toString() : null,
      cgstPercent: cgst > 0 ? cgst.toString() : null,
      igstPercent: igst > 0 ? igst.toString() : null,
      ugstPercent: ugst > 0 ? ugst.toString() : null,
      sgstAmount: sgstAmount > 0 ? sgstAmount.toString() : null,
      cgstAmount: cgstAmount > 0 ? cgstAmount.toString() : null,
      igstAmount: igstAmount > 0 ? igstAmount.toString() : null,
      ugstAmount: ugstAmount > 0 ? ugstAmount.toString() : null,
      totalGst: totalGst > 0 ? totalGst.toString() : null,
      amount: totalAmount.toString(),
      description,
      paymentMethod: paymentMethodEnum,
      status: ReceiptStatus.GENERATED,
      createdBy: currentUser.id,
    };

    const newReceipt = await prisma.receipt.create({
      data: receiptData,
    });

    return res.status(201).json({
      message: "Receipt created!",
      data: newReceipt,
    });
  },
);

router.get("/", withPermission(Permission.GET_RECEIPTS), async (req, res) => {
  const { schoolId, status } = req.query;

  const where = {
    deletedAt: null,
  };

  if (schoolId) {
    where.schoolId = schoolId;
  }

  if (status) {
    where.status = status;
  }

  const receipts = await prisma.receipt.findMany({
    where,
    include: {
      school: {
        select: {
          id: true,
          name: true,
          code: true,
        },
      },
    },
    orderBy: {
      createdAt: "desc",
    },
    ...paginateUtil.getPaginationParams(req),
  });

  return res.json({
    message: "Receipts fetched!",
    data: receipts,
  });
});

router.get(
  "/:id",
  withPermission(Permission.GET_RECEIPTS),
  async (req, res) => {
    const { id } = req.params;

    const receipt = await prisma.receipt.findUniqueOrThrow({
      where: { id },
      include: {
        school: {
          select: {
            id: true,
            name: true,
            code: true,
            email: true,
            phone: true,
            address: true,
          },
        },
      },
    });

    return res.json({
      message: "Receipt fetched!",
      data: receipt,
    });
  },
);

router.patch(
  "/:id",
  withPermission(Permission.UPDATE_RECEIPT),
  async (req, res) => {
    const { id } = req.params;
    const {
      schoolId,
      receiptNumber,
      baseAmount,
      sgstPercent,
      cgstPercent,
      igstPercent,
      ugstPercent,
      description,
      paymentMethod,
      status,
    } = req.body.request;
    const currentUser = req.context.user;

    const updateData = {
      updatedBy: currentUser.id,
    };

    // Update school if provided
    if (schoolId) {
      await prisma.school.findUniqueOrThrow({
        where: { id: schoolId },
      });
      updateData.schoolId = schoolId;
    }

    // Update receipt number if provided
    if (receiptNumber) {
      updateData.receiptNumber = receiptNumber;
    }

    // Update amounts and recalculate GST if baseAmount or GST percentages are provided
    if (
      baseAmount !== undefined ||
      sgstPercent !== undefined ||
      cgstPercent !== undefined ||
      igstPercent !== undefined ||
      ugstPercent !== undefined
    ) {
      // Fetch current receipt to get existing values if not provided
      const currentReceipt = await prisma.receipt.findUniqueOrThrow({
        where: { id },
      });

      const base =
        baseAmount !== undefined
          ? parseFloat(baseAmount)
          : parseFloat(currentReceipt.baseAmount);

      const sgst =
        sgstPercent !== undefined
          ? sgstPercent
            ? parseFloat(sgstPercent)
            : 0
          : currentReceipt.sgstPercent
            ? parseFloat(currentReceipt.sgstPercent)
            : 0;

      const cgst =
        cgstPercent !== undefined
          ? cgstPercent
            ? parseFloat(cgstPercent)
            : 0
          : currentReceipt.cgstPercent
            ? parseFloat(currentReceipt.cgstPercent)
            : 0;

      const igst =
        igstPercent !== undefined
          ? igstPercent
            ? parseFloat(igstPercent)
            : 0
          : currentReceipt.igstPercent
            ? parseFloat(currentReceipt.igstPercent)
            : 0;

      const ugst =
        ugstPercent !== undefined
          ? ugstPercent
            ? parseFloat(ugstPercent)
            : 0
          : currentReceipt.ugstPercent
            ? parseFloat(currentReceipt.ugstPercent)
            : 0;

      const sgstAmount = sgst > 0 ? (base * sgst) / 100 : 0;
      const cgstAmount = cgst > 0 ? (base * cgst) / 100 : 0;
      const igstAmount = igst > 0 ? (base * igst) / 100 : 0;
      const ugstAmount = ugst > 0 ? (base * ugst) / 100 : 0;
      const totalGst = sgstAmount + cgstAmount + igstAmount + ugstAmount;
      const totalAmount = base + totalGst;

      updateData.baseAmount = base.toString();
      updateData.sgstPercent = sgst > 0 ? sgst.toString() : null;
      updateData.cgstPercent = cgst > 0 ? cgst.toString() : null;
      updateData.igstPercent = igst > 0 ? igst.toString() : null;
      updateData.ugstPercent = ugst > 0 ? ugst.toString() : null;
      updateData.sgstAmount = sgstAmount > 0 ? sgstAmount.toString() : null;
      updateData.cgstAmount = cgstAmount > 0 ? cgstAmount.toString() : null;
      updateData.igstAmount = igstAmount > 0 ? igstAmount.toString() : null;
      updateData.ugstAmount = ugstAmount > 0 ? ugstAmount.toString() : null;
      updateData.totalGst = totalGst > 0 ? totalGst.toString() : null;
      updateData.amount = totalAmount.toString();
    }

    if (description !== undefined) {
      updateData.description = description;
    }

    if (paymentMethod) {
      const paymentMethodEnum =
        PaymentMethod[paymentMethod.replace(/\s+/g, "_").toUpperCase()] ||
        PaymentMethod.BANK_TRANSFER;
      updateData.paymentMethod = paymentMethodEnum;
    }

    if (status) {
      updateData.status = status;
    }

    const updatedReceipt = await prisma.receipt.update({
      where: { id },
      data: updateData,
    });

    return res.json({
      message: "Receipt updated!",
      data: updatedReceipt,
    });
  },
);

router.delete(
  "/:id",
  withPermission(Permission.DELETE_RECEIPT),
  async (req, res) => {
    const { id } = req.params;
    const currentUser = req.context.user;

    await prisma.receipt.update({
      where: { id },
      data: {
        deletedAt: new Date(),
        deletedBy: currentUser.id,
      },
    });

    return res.json({
      message: "Receipt deleted!",
    });
  },
);

// Generate receipt HTML for printing
router.post(
  "/:id/generate",
  withPermission(Permission.GET_RECEIPTS),
  async (req, res) => {
    const { id } = req.params;

    // Fetch receipt with school details
    const receipt = await prisma.receipt.findUniqueOrThrow({
      where: { id },
      include: {
        school: {
          select: {
            id: true,
            name: true,
            code: true,
            email: true,
            phone: true,
            address: true,
          },
        },
      },
    });

    // Escape HTML to prevent XSS
    const escapeHtml = (text) => {
      if (!text) return "";
      const map = {
        "&": "&amp;",
        "<": "&lt;",
        ">": "&gt;",
        '"': "&quot;",
        "'": "&#039;",
      };
      return String(text).replace(/[&<>"']/g, (m) => map[m]);
    };

    // Format date
    const issueDate = new Date(receipt.createdAt).toLocaleDateString("en-IN", {
      year: "numeric",
      month: "long",
      day: "numeric",
    });

    // Format payment method for display
    const paymentMethodDisplay = receipt.paymentMethod
      .replace(/_/g, " ")
      .toLowerCase()
      .replace(/\b\w/g, (c) => c.toUpperCase());

    // Prepare school address
    const schoolAddress = receipt.school.address
      ? receipt.school.address.join("<br>")
      : "N/A";
    const billTo = `<strong>${escapeHtml(receipt.school.name)}</strong><br>${schoolAddress}`;
    const shipTo = schoolAddress;

    // Parse amounts
    const baseAmount = parseFloat(receipt.baseAmount) || 0;
    const totalAmount = parseFloat(receipt.amount) || 0;

    // Determine tax type
    const hasSgstUgst =
      (parseFloat(receipt.sgstPercent) || 0) > 0 ||
      (parseFloat(receipt.ugstPercent) || 0) > 0;
    const hasCgstIgst =
      (parseFloat(receipt.cgstPercent) || 0) > 0 ||
      (parseFloat(receipt.igstPercent) || 0) > 0;

    let tax1Name, tax2Name, tax1Percent, tax2Percent, tax1Amount, tax2Amount;

    if (hasSgstUgst) {
      tax1Name = "SGST";
      tax2Name = "UGST";
      tax1Percent = receipt.sgstPercent || "0";
      tax2Percent = receipt.ugstPercent || "0";
      tax1Amount = receipt.sgstAmount || "0";
      tax2Amount = receipt.ugstAmount || "0";
    } else if (hasCgstIgst) {
      tax1Name = "CGST";
      tax2Name = "IGST";
      tax1Percent = receipt.cgstPercent || "0";
      tax2Percent = receipt.igstPercent || "0";
      tax1Amount = receipt.cgstAmount || "0";
      tax2Amount = receipt.igstAmount || "0";
    } else {
      // Default to CGST/IGST with 0%
      tax1Name = "CGST";
      tax2Name = "IGST";
      tax1Percent = "0";
      tax2Percent = "0";
      tax1Amount = "0";
      tax2Amount = "0";
    }

    // Format amounts for display
    const formatAmount = (amt) => {
      const num = parseFloat(amt) || 0;
      return num.toLocaleString("en-IN", {
        minimumFractionDigits: 2,
        maximumFractionDigits: 2,
      });
    };

    // Load template and replace placeholders
    let receiptHTML = getReceiptTemplate();

    // Replace all template variables
    receiptHTML = receiptHTML.replace(
      /\{\{RECEIPT_NO\}\}/g,
      escapeHtml(receipt.receiptNumber),
    );
    receiptHTML = receiptHTML.replace(/\{\{BILL_TO\}\}/g, billTo);
    receiptHTML = receiptHTML.replace(/\{\{SHIP_TO\}\}/g, shipTo);
    receiptHTML = receiptHTML.replace(/\{\{ISSUE_DATE\}\}/g, issueDate);
    receiptHTML = receiptHTML.replace(
      /\{\{PAYMENT_METHOD\}\}/g,
      paymentMethodDisplay,
    );
    receiptHTML = receiptHTML.replace(/\{\{TAX_1\}\}/g, tax1Name);
    receiptHTML = receiptHTML.replace(/\{\{TAX_2\}\}/g, tax2Name);
    receiptHTML = receiptHTML.replace(
      /\{\{TAX_1_PERCENTAGE\}\}/g,
      tax1Percent + "%",
    );
    receiptHTML = receiptHTML.replace(
      /\{\{TAX_2_PERCENTAGE\}\}/g,
      tax2Percent + "%",
    );
    receiptHTML = receiptHTML.replace(
      /\{\{TAX_1_AMOUNT\}\}/g,
      formatAmount(tax1Amount),
    );
    receiptHTML = receiptHTML.replace(
      /\{\{TAX_2_AMOUNT\}\}/g,
      formatAmount(tax2Amount),
    );
    receiptHTML = receiptHTML.replace(
      /\{\{PRICE\}\}/g,
      formatAmount(baseAmount),
    );
    receiptHTML = receiptHTML.replace(
      /\{\{TAXABLE_VALUE\}\}/g,
      formatAmount(baseAmount),
    );
    receiptHTML = receiptHTML.replace(
      /\{\{AMOUNT\}\}/g,
      formatAmount(totalAmount),
    );
    receiptHTML = receiptHTML.replace(
      /\{\{AMOUNT_IN_WORDS\}\}/g,
      numberToWords(totalAmount),
    );
    receiptHTML = receiptHTML.replace(
      /\{\{NOTES\}\}/g,
      escapeHtml(receipt.description) || "Thank you for your business.",
    );

    // Trim the result
    receiptHTML = receiptHTML.trim();

    // Return the HTML as a data URL or base64 encoded
    const base64HTML = Buffer.from(receiptHTML).toString("base64");
    const dataUrl = `data:text/html;base64,${base64HTML}`;

    return res.json({
      message: "Receipt generated successfully!",
      data: {
        html: receiptHTML,
        printUrl: dataUrl,
        receipt: receipt,
      },
    });
  },
);

export default router;
